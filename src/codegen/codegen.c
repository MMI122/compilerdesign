/*
 * NatureLang Compiler
 * Copyright (c) 2026
 * 
 * Code Generator Implementation
 * 
 * Translates validated AST to C source code.
 */

#define _POSIX_C_SOURCE 200809L
#include "codegen.h"
#include "ast.h"
#include "symbol_table.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

/* Forward declarations */
static void codegen_node(CodegenContext *ctx, ASTNode *node);
static void codegen_statement(CodegenContext *ctx, ASTNode *node);
static void codegen_expression(CodegenContext *ctx, ASTNode *node);

/* Buffer management */
static void buffer_init(CodegenContext *ctx) {
    ctx->buffer_capacity = 8192;
    ctx->buffer = malloc(ctx->buffer_capacity);
    ctx->buffer_size = 0;
    ctx->buffer[0] = '\0';
}

static void buffer_ensure_capacity(CodegenContext *ctx, size_t needed) {
    if (ctx->buffer_size + needed >= ctx->buffer_capacity) {
        ctx->buffer_capacity = (ctx->buffer_size + needed) * 2;
        ctx->buffer = realloc(ctx->buffer, ctx->buffer_capacity);
    }
}

static void emit(CodegenContext *ctx, const char *fmt, ...) {
    va_list args;
    char temp[4096];
    
    va_start(args, fmt);
    int len = vsnprintf(temp, sizeof(temp), fmt, args);
    va_end(args);
    
    if (len > 0) {
        buffer_ensure_capacity(ctx, (size_t)len + 1);
        memcpy(ctx->buffer + ctx->buffer_size, temp, (size_t)len);
        ctx->buffer_size += (size_t)len;
        ctx->buffer[ctx->buffer_size] = '\0';
    }
}

static void emit_indent(CodegenContext *ctx) {
    int spaces = ctx->indent_level * ctx->options.indent_size;
    for (int i = 0; i < spaces; i++) {
        emit(ctx, " ");
    }
}

static void emit_line(CodegenContext *ctx, const char *fmt, ...) {
    va_list args;
    char temp[4096];
    
    emit_indent(ctx);
    
    va_start(args, fmt);
    int len = vsnprintf(temp, sizeof(temp), fmt, args);
    va_end(args);
    
    if (len > 0) {
        buffer_ensure_capacity(ctx, (size_t)len + 2);
        memcpy(ctx->buffer + ctx->buffer_size, temp, (size_t)len);
        ctx->buffer_size += (size_t)len;
        ctx->buffer[ctx->buffer_size++] = '\n';
        ctx->buffer[ctx->buffer_size] = '\0';
    }
}

static void emit_newline(CodegenContext *ctx) {
    emit(ctx, "\n");
}

/* Code generation options */
CodegenOptions codegen_default_options(void) {
    CodegenOptions opts = {
        .emit_comments = 1,
        .emit_debug_info = 0,
        .use_safe_functions = 1,
        .indent_size = 4
    };
    return opts;
}

/* Create code generator */
CodegenContext *codegen_create(SymbolTable *symtab, CodegenOptions *options) {
    CodegenContext *ctx = calloc(1, sizeof(CodegenContext));
    if (!ctx) return NULL;
    
    ctx->symtab = symtab;
    if (options) {
        ctx->options = *options;
    } else {
        ctx->options = codegen_default_options();
    }
    
    buffer_init(ctx);
    ctx->indent_level = 0;
    ctx->temp_var_counter = 0;
    ctx->label_counter = 0;
    ctx->error_count = 0;
    ctx->in_function = 0;
    ctx->in_loop = 0;
    ctx->needs_input_buffer = 0;
    ctx->needs_list_support = 0;
    
    return ctx;
}

/* Destroy code generator */
void codegen_destroy(CodegenContext *ctx) {
    if (ctx) {
        free(ctx->buffer);
        free(ctx);
    }
}

/* Type conversion */
const char *naturelang_type_to_c(DataType type) {
    switch (type) {
        case TYPE_NUMBER:  return "long long";
        case TYPE_DECIMAL: return "double";
        case TYPE_TEXT:    return "char*";
        case TYPE_FLAG:    return "int";
        case TYPE_LIST:    return "NLList*";
        case TYPE_NOTHING: return "void";
        default:           return "int";  /* Unknown -> default to int */
    }
}

/* Generate temporary variable */
char *codegen_temp_var(CodegenContext *ctx) {
    char *name = malloc(32);
    snprintf(name, 32, "_nl_tmp%d", ctx->temp_var_counter++);
    return name;
}

/* Generate label */
char *codegen_label(CodegenContext *ctx, const char *prefix) {
    char *name = malloc(64);
    snprintf(name, 64, "_nl_%s%d", prefix, ctx->label_counter++);
    return name;
}

/* Report error */
static void codegen_error(CodegenContext *ctx, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vsnprintf(ctx->error_message, sizeof(ctx->error_message), fmt, args);
    va_end(args);
    ctx->error_count++;
}

/* Emit standard headers and runtime includes */
static void emit_headers(CodegenContext *ctx) {
    emit_line(ctx, "/*");
    emit_line(ctx, " * Generated by NatureLang Compiler");
    emit_line(ctx, " * Do not edit this file directly.");
    emit_line(ctx, " */");
    emit_newline(ctx);
    emit_line(ctx, "#include <stdio.h>");
    emit_line(ctx, "#include <stdlib.h>");
    emit_line(ctx, "#include <string.h>");
    emit_line(ctx, "#include <stdbool.h>");
    emit_line(ctx, "#include <math.h>");
    emit_line(ctx, "#include \"naturelang_runtime.h\"");
    emit_newline(ctx);
}

/* Emit input buffer if needed */
static void emit_input_buffer(CodegenContext *ctx) {
    if (ctx->needs_input_buffer) {
        emit_line(ctx, "/* Input buffer for reading user input */");
        emit_line(ctx, "static char _nl_input_buffer[4096];");
        emit_newline(ctx);
    }
}

/* Convert identifier to valid C name */
static void emit_identifier(CodegenContext *ctx, const char *name) {
    /* Replace spaces with underscores for multi-word identifiers */
    while (*name) {
        if (*name == ' ') {
            emit(ctx, "_");
        } else {
            emit(ctx, "%c", *name);
        }
        name++;
    }
}

/* Escape string for C */
static void emit_string_literal(CodegenContext *ctx, const char *str) {
    emit(ctx, "\"");
    while (*str) {
        switch (*str) {
            case '"':  emit(ctx, "\\\""); break;
            case '\\': emit(ctx, "\\\\"); break;
            case '\n': emit(ctx, "\\n"); break;
            case '\t': emit(ctx, "\\t"); break;
            case '\r': emit(ctx, "\\r"); break;
            default:   emit(ctx, "%c", *str); break;
        }
        str++;
    }
    emit(ctx, "\"");
}

/* Generate expression */
static void codegen_expression(CodegenContext *ctx, ASTNode *node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_LITERAL_INT:
            emit(ctx, "%lld", node->data.literal_int.value);
            break;
            
        case AST_LITERAL_FLOAT:
            emit(ctx, "%g", node->data.literal_float.value);
            break;
            
        case AST_LITERAL_STRING:
            emit_string_literal(ctx, node->data.literal_string.value);
            break;
            
        case AST_LITERAL_BOOL:
            emit(ctx, node->data.literal_bool.value ? "1" : "0");
            break;
            
        case AST_IDENTIFIER:
            emit_identifier(ctx, node->data.identifier.name);
            break;
            
        case AST_BINARY_OP: {
            const char *op_str;
            int needs_parens = 1;
            int is_comparison = 0;
            int is_string_concat = 0;
            Operator op = node->data.binary_op.op;
            ASTNode *left = node->data.binary_op.left;
            ASTNode *right = node->data.binary_op.right;
            
            /* Check for string concatenation */
            if (op == OP_ADD && 
                (left->data_type == TYPE_TEXT || right->data_type == TYPE_TEXT)) {
                is_string_concat = 1;
            }
            
            if (is_string_concat) {
                /* Use runtime string concatenation */
                emit(ctx, "nl_concat(");
                if (left->data_type == TYPE_TEXT) {
                    codegen_expression(ctx, left);
                } else {
                    emit(ctx, "nl_to_string(");
                    codegen_expression(ctx, left);
                    emit(ctx, ")");
                }
                emit(ctx, ", ");
                if (right->data_type == TYPE_TEXT) {
                    codegen_expression(ctx, right);
                } else {
                    emit(ctx, "nl_to_string(");
                    codegen_expression(ctx, right);
                    emit(ctx, ")");
                }
                emit(ctx, ")");
                break;
            }
            
            switch (op) {
                case OP_ADD: op_str = "+"; break;
                case OP_SUB: op_str = "-"; break;
                case OP_MUL: op_str = "*"; break;
                case OP_DIV: op_str = "/"; break;
                case OP_MOD: op_str = "%%"; break;
                case OP_POW:
                    /* Use pow() for exponentiation */
                    emit(ctx, "pow(");
                    codegen_expression(ctx, left);
                    emit(ctx, ", ");
                    codegen_expression(ctx, right);
                    emit(ctx, ")");
                    return;
                case OP_EQ:  op_str = "=="; is_comparison = 1; break;
                case OP_NEQ: op_str = "!="; is_comparison = 1; break;
                case OP_LT:  op_str = "<"; is_comparison = 1; break;
                case OP_LTE: op_str = "<="; is_comparison = 1; break;
                case OP_GT:  op_str = ">"; is_comparison = 1; break;
                case OP_GTE: op_str = ">="; is_comparison = 1; break;
                case OP_AND: op_str = "&&"; break;
                case OP_OR:  op_str = "||"; break;
                default:     op_str = "?"; break;
            }
            
            /* String comparisons need strcmp */
            if (is_comparison && 
                (left->data_type == TYPE_TEXT || right->data_type == TYPE_TEXT)) {
                emit(ctx, "(strcmp(");
                codegen_expression(ctx, left);
                emit(ctx, ", ");
                codegen_expression(ctx, right);
                emit(ctx, ") %s 0)", op_str);
            } else {
                if (needs_parens) emit(ctx, "(");
                codegen_expression(ctx, left);
                emit(ctx, " %s ", op_str);
                codegen_expression(ctx, right);
                if (needs_parens) emit(ctx, ")");
            }
            break;
        }
        
        case AST_UNARY_OP: {
            Operator op = node->data.unary_op.op;
            ASTNode *operand = node->data.unary_op.operand;
            
            switch (op) {
                case OP_NEG:
                    emit(ctx, "(-");
                    codegen_expression(ctx, operand);
                    emit(ctx, ")");
                    break;
                case OP_NOT:
                    emit(ctx, "(!");
                    codegen_expression(ctx, operand);
                    emit(ctx, ")");
                    break;
                default:
                    codegen_expression(ctx, operand);
                    break;
            }
            break;
        }
            
        case AST_TERNARY_OP: {
            /* is between operator: value >= low && value <= high */
            ASTNode *operand = node->data.ternary_op.operand;
            ASTNode *lower = node->data.ternary_op.lower;
            ASTNode *upper = node->data.ternary_op.upper;
            
            emit(ctx, "((");
            codegen_expression(ctx, operand);
            emit(ctx, " >= ");
            codegen_expression(ctx, lower);
            emit(ctx, ") && (");
            codegen_expression(ctx, operand);
            emit(ctx, " <= ");
            codegen_expression(ctx, upper);
            emit(ctx, "))");
            break;
        }
            
        case AST_FUNC_CALL: {
            emit_identifier(ctx, node->data.func_call.name);
            emit(ctx, "(");
            ASTNodeList *args = node->data.func_call.args;
            if (args) {
                for (size_t i = 0; i < args->count; i++) {
                    if (i > 0) emit(ctx, ", ");
                    codegen_expression(ctx, args->nodes[i]);
                }
            }
            emit(ctx, ")");
            break;
        }
        
        case AST_LIST: {
            ASTNodeList *elements = node->data.list_literal.elements;
            size_t count = elements ? elements->count : 0;
            emit(ctx, "nl_list_create(%zu", count);
            if (elements) {
                for (size_t i = 0; i < elements->count; i++) {
                    emit(ctx, ", ");
                    codegen_expression(ctx, elements->nodes[i]);
                }
            }
            emit(ctx, ")");
            ctx->needs_list_support = 1;
            break;
        }
        
        case AST_INDEX: {
            emit(ctx, "nl_list_get(");
            codegen_expression(ctx, node->data.index_expr.array);
            emit(ctx, ", ");
            codegen_expression(ctx, node->data.index_expr.index);
            emit(ctx, ")");
            break;
        }
        
        default:
            codegen_error(ctx, "Unknown expression node type: %d", node->type);
            emit(ctx, "/* ERROR: unknown expression */");
            break;
    }
}

/* Generate variable declaration */
static void codegen_var_decl(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    
    /* Determine type */
    DataType type = node->data.var_decl.var_type;
    const char *c_type = naturelang_type_to_c(type);
    
    if (node->data.var_decl.is_const) {
        emit(ctx, "const ");
    }
    
    emit(ctx, "%s ", c_type);
    emit_identifier(ctx, node->data.var_decl.name);
    
    /* Initialize if provided */
    if (node->data.var_decl.initializer) {
        emit(ctx, " = ");
        codegen_expression(ctx, node->data.var_decl.initializer);
    } else {
        /* Default initialization */
        switch (type) {
            case TYPE_NUMBER:
            case TYPE_DECIMAL:
                emit(ctx, " = 0");
                break;
            case TYPE_TEXT:
                emit(ctx, " = \"\"");
                break;
            case TYPE_FLAG:
                emit(ctx, " = 0");
                break;
            default:
                break;
        }
    }
    
    emit(ctx, ";\n");
}

/* Generate assignment */
static void codegen_assignment(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    codegen_expression(ctx, node->data.assign.target);
    emit(ctx, " = ");
    codegen_expression(ctx, node->data.assign.value);
    emit(ctx, ";\n");
}

/* Generate display statement */
static void codegen_display(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    
    ASTNode *value = node->data.display_stmt.value;
    if (!value) {
        emit(ctx, "printf(\"\\n\");\n");
        return;
    }
    
    /* Determine format based on expression type */
    DataType type = value->data_type;
    
    switch (type) {
        case TYPE_NUMBER:
            emit(ctx, "printf(\"%%lld\\n\", (long long)");
            codegen_expression(ctx, value);
            emit(ctx, ");\n");
            break;
        case TYPE_DECIMAL:
            emit(ctx, "printf(\"%%g\\n\", (double)");
            codegen_expression(ctx, value);
            emit(ctx, ");\n");
            break;
        case TYPE_TEXT:
            emit(ctx, "printf(\"%%s\\n\", ");
            codegen_expression(ctx, value);
            emit(ctx, ");\n");
            break;
        case TYPE_FLAG:
            emit(ctx, "printf(\"%%s\\n\", ");
            codegen_expression(ctx, value);
            emit(ctx, " ? \"yes\" : \"no\");\n");
            break;
        default:
            emit(ctx, "nl_display(");
            codegen_expression(ctx, value);
            emit(ctx, ");\n");
            break;
    }
}

/* Generate ask statement (input with prompt) */
static void codegen_ask(CodegenContext *ctx, ASTNode *node) {
    ctx->needs_input_buffer = 1;
    emit_indent(ctx);
    
    /* Get target variable type */
    DataType type = TYPE_TEXT;  /* Default */
    const char *target = node->data.ask_stmt.target_var;
    Symbol *sym = symtab_lookup(ctx->symtab, target);
    if (sym) {
        type = sym->type;
    }
    
    /* Print prompt if provided */
    if (node->data.ask_stmt.prompt) {
        emit(ctx, "printf(\"%%s\", ");
        codegen_expression(ctx, node->data.ask_stmt.prompt);
        emit(ctx, "); fflush(stdout);\n");
        emit_indent(ctx);
    }
    
    /* Read input based on type */
    switch (type) {
        case TYPE_NUMBER:
            emit(ctx, "fgets(_nl_input_buffer, sizeof(_nl_input_buffer), stdin); ");
            emit_identifier(ctx, target);
            emit(ctx, " = atoll(_nl_input_buffer);\n");
            break;
        case TYPE_DECIMAL:
            emit(ctx, "fgets(_nl_input_buffer, sizeof(_nl_input_buffer), stdin); ");
            emit_identifier(ctx, target);
            emit(ctx, " = atof(_nl_input_buffer);\n");
            break;
        case TYPE_TEXT:
            emit(ctx, "fgets(_nl_input_buffer, sizeof(_nl_input_buffer), stdin); ");
            emit(ctx, "_nl_input_buffer[strcspn(_nl_input_buffer, \"\\n\")] = 0; ");
            emit_identifier(ctx, target);
            emit(ctx, " = strdup(_nl_input_buffer);\n");
            break;
        default:
            emit(ctx, "fgets(_nl_input_buffer, sizeof(_nl_input_buffer), stdin);\n");
            break;
    }
}

/* Generate read statement (simple input) */
static void codegen_read(CodegenContext *ctx, ASTNode *node) {
    ctx->needs_input_buffer = 1;
    emit_indent(ctx);
    
    const char *target = node->data.read_stmt.target_var;
    
    /* Get target variable type */
    DataType type = TYPE_TEXT;  /* Default */
    Symbol *sym = symtab_lookup(ctx->symtab, target);
    if (sym) {
        type = sym->type;
    }
    
    /* Read input based on type */
    switch (type) {
        case TYPE_NUMBER:
            emit(ctx, "fgets(_nl_input_buffer, sizeof(_nl_input_buffer), stdin); ");
            emit_identifier(ctx, target);
            emit(ctx, " = atoll(_nl_input_buffer);\n");
            break;
        case TYPE_DECIMAL:
            emit(ctx, "fgets(_nl_input_buffer, sizeof(_nl_input_buffer), stdin); ");
            emit_identifier(ctx, target);
            emit(ctx, " = atof(_nl_input_buffer);\n");
            break;
        case TYPE_TEXT:
            emit(ctx, "fgets(_nl_input_buffer, sizeof(_nl_input_buffer), stdin); ");
            emit(ctx, "_nl_input_buffer[strcspn(_nl_input_buffer, \"\\n\")] = 0; ");
            emit_identifier(ctx, target);
            emit(ctx, " = strdup(_nl_input_buffer);\n");
            break;
        default:
            emit(ctx, "fgets(_nl_input_buffer, sizeof(_nl_input_buffer), stdin);\n");
            break;
    }
}

/* Generate if statement */
static void codegen_if(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    emit(ctx, "if (");
    codegen_expression(ctx, node->data.if_stmt.condition);
    emit(ctx, ") {\n");
    
    ctx->indent_level++;
    if (node->data.if_stmt.then_branch) {
        codegen_node(ctx, node->data.if_stmt.then_branch);
    }
    ctx->indent_level--;
    
    emit_indent(ctx);
    emit(ctx, "}");
    
    if (node->data.if_stmt.else_branch) {
        emit(ctx, " else {\n");
        ctx->indent_level++;
        codegen_node(ctx, node->data.if_stmt.else_branch);
        ctx->indent_level--;
        emit_indent(ctx);
        emit(ctx, "}");
    }
    emit(ctx, "\n");
}

/* Generate while loop */
static void codegen_while(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    emit(ctx, "while (");
    codegen_expression(ctx, node->data.while_stmt.condition);
    emit(ctx, ") {\n");
    
    ctx->indent_level++;
    ctx->in_loop++;
    if (node->data.while_stmt.body) {
        codegen_node(ctx, node->data.while_stmt.body);
    }
    ctx->in_loop--;
    ctx->indent_level--;
    
    emit_indent(ctx);
    emit(ctx, "}\n");
}

/* Generate repeat loop */
static void codegen_repeat(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    
    char *iter_var = codegen_temp_var(ctx);
    char *limit_var = codegen_temp_var(ctx);
    
    emit(ctx, "{\n");
    ctx->indent_level++;
    
    emit_indent(ctx);
    emit(ctx, "long long %s = ", limit_var);
    codegen_expression(ctx, node->data.repeat_stmt.count);
    emit(ctx, ";\n");
    
    emit_indent(ctx);
    emit(ctx, "for (long long %s = 0; %s < %s; %s++) {\n", 
         iter_var, iter_var, limit_var, iter_var);
    
    ctx->indent_level++;
    ctx->in_loop++;
    if (node->data.repeat_stmt.body) {
        codegen_node(ctx, node->data.repeat_stmt.body);
    }
    ctx->in_loop--;
    ctx->indent_level--;
    
    emit_indent(ctx);
    emit(ctx, "}\n");
    
    ctx->indent_level--;
    emit_indent(ctx);
    emit(ctx, "}\n");
    
    free(iter_var);
    free(limit_var);
}

/* Generate foreach loop */
static void codegen_foreach(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    
    /* Generate iteration over list */
    char *iter_var = codegen_temp_var(ctx);
    char *list_var = codegen_temp_var(ctx);
    
    emit(ctx, "{\n");
    ctx->indent_level++;
    
    emit_indent(ctx);
    emit(ctx, "NLList* %s = ", list_var);
    codegen_expression(ctx, node->data.for_each_stmt.iterable);
    emit(ctx, ";\n");
    
    emit_indent(ctx);
    emit(ctx, "for (int %s = 0; %s < %s->length; %s++) {\n", 
         iter_var, iter_var, list_var, iter_var);
    
    ctx->indent_level++;
    
    emit_indent(ctx);
    emit(ctx, "long long ");  /* Assume numeric for now */
    emit_identifier(ctx, node->data.for_each_stmt.iterator_name);
    emit(ctx, " = nl_list_get_num(%s, %s);\n", list_var, iter_var);
    
    ctx->in_loop++;
    if (node->data.for_each_stmt.body) {
        codegen_node(ctx, node->data.for_each_stmt.body);
    }
    ctx->in_loop--;
    
    ctx->indent_level--;
    emit_indent(ctx);
    emit(ctx, "}\n");
    
    ctx->indent_level--;
    emit_indent(ctx);
    emit(ctx, "}\n");
    
    free(iter_var);
    free(list_var);
}

/* Generate function declaration */
static void codegen_function(CodegenContext *ctx, ASTNode *node) {
    /* Return type */
    const char *ret_type = naturelang_type_to_c(node->data.func_decl.return_type);
    emit(ctx, "%s ", ret_type);
    emit_identifier(ctx, node->data.func_decl.name);
    emit(ctx, "(");
    
    /* Parameters */
    ASTNodeList *params = node->data.func_decl.params;
    if (params && params->count > 0) {
        for (size_t i = 0; i < params->count; i++) {
            if (i > 0) emit(ctx, ", ");
            ASTNode *param = params->nodes[i];
            const char *param_type = naturelang_type_to_c(param->data.param_decl.param_type);
            emit(ctx, "%s ", param_type);
            emit_identifier(ctx, param->data.param_decl.name);
        }
    } else {
        emit(ctx, "void");
    }
    
    emit(ctx, ") {\n");
    
    ctx->indent_level++;
    ctx->in_function = 1;
    
    if (node->data.func_decl.body) {
        codegen_node(ctx, node->data.func_decl.body);
    }
    
    ctx->in_function = 0;
    ctx->indent_level--;
    
    emit(ctx, "}\n\n");
}

/* Generate return statement */
static void codegen_return(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    if (node->data.return_stmt.value) {
        emit(ctx, "return ");
        codegen_expression(ctx, node->data.return_stmt.value);
        emit(ctx, ";\n");
    } else {
        emit(ctx, "return;\n");
    }
}

/* Generate break statement */
static void codegen_break(CodegenContext *ctx, ASTNode *node) {
    (void)node;  /* Unused */
    emit_indent(ctx);
    emit(ctx, "break;\n");
}

/* Generate continue statement */
static void codegen_continue(CodegenContext *ctx, ASTNode *node) {
    (void)node;  /* Unused */
    emit_indent(ctx);
    emit(ctx, "continue;\n");
}

/* Generate secure zone (no special C handling, just emit body) */
static void codegen_secure_zone(CodegenContext *ctx, ASTNode *node) {
    if (ctx->options.emit_comments) {
        emit_indent(ctx);
        emit(ctx, "/* BEGIN SECURE ZONE */\n");
    }
    
    emit_indent(ctx);
    emit(ctx, "{\n");
    ctx->indent_level++;
    
    if (node->data.secure_zone.body) {
        codegen_node(ctx, node->data.secure_zone.body);
    }
    
    ctx->indent_level--;
    emit_indent(ctx);
    emit(ctx, "}\n");
    
    if (ctx->options.emit_comments) {
        emit_indent(ctx);
        emit(ctx, "/* END SECURE ZONE */\n");
    }
}

/* Generate expression statement */
static void codegen_expr_stmt(CodegenContext *ctx, ASTNode *node) {
    emit_indent(ctx);
    codegen_expression(ctx, node->data.expr_stmt.expr);
    emit(ctx, ";\n");
}

/* Generate a single statement */
static void codegen_statement(CodegenContext *ctx, ASTNode *node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_VAR_DECL:
            codegen_var_decl(ctx, node);
            break;
        case AST_ASSIGN:
            codegen_assignment(ctx, node);
            break;
        case AST_DISPLAY:
            codegen_display(ctx, node);
            break;
        case AST_ASK:
            codegen_ask(ctx, node);
            break;
        case AST_READ:
            codegen_read(ctx, node);
            break;
        case AST_IF:
            codegen_if(ctx, node);
            break;
        case AST_WHILE:
            codegen_while(ctx, node);
            break;
        case AST_REPEAT:
            codegen_repeat(ctx, node);
            break;
        case AST_FOR_EACH:
            codegen_foreach(ctx, node);
            break;
        case AST_FUNC_DECL:
            codegen_function(ctx, node);
            break;
        case AST_RETURN:
            codegen_return(ctx, node);
            break;
        case AST_BREAK:
            codegen_break(ctx, node);
            break;
        case AST_CONTINUE:
            codegen_continue(ctx, node);
            break;
        case AST_SECURE_ZONE:
            codegen_secure_zone(ctx, node);
            break;
        case AST_EXPR_STMT:
            codegen_expr_stmt(ctx, node);
            break;
        case AST_BLOCK: {
            ASTNodeList *stmts = node->data.block.statements;
            if (stmts) {
                for (size_t i = 0; i < stmts->count; i++) {
                    codegen_statement(ctx, stmts->nodes[i]);
                }
            }
            break;
        }
        default:
            /* Try as expression */
            emit_indent(ctx);
            codegen_expression(ctx, node);
            emit(ctx, ";\n");
            break;
    }
}

/* Generate node - dispatcher */
static void codegen_node(CodegenContext *ctx, ASTNode *node) {
    if (!node) return;
    
    if (node->type == AST_PROGRAM) {
        ASTNodeList *stmts = node->data.program.statements;
        if (stmts) {
            for (size_t i = 0; i < stmts->count; i++) {
                codegen_statement(ctx, stmts->nodes[i]);
            }
        }
    } else if (node->type == AST_BLOCK) {
        ASTNodeList *stmts = node->data.block.statements;
        if (stmts) {
            for (size_t i = 0; i < stmts->count; i++) {
                codegen_statement(ctx, stmts->nodes[i]);
            }
        }
    } else {
        codegen_statement(ctx, node);
    }
}

/* Collect function declarations for forward declarations */
static void collect_functions(ASTNode *node, ASTNode **funcs, int *count, int max) {
    if (!node) return;
    
    if (node->type == AST_FUNC_DECL && *count < max) {
        funcs[(*count)++] = node;
    }
    
    if (node->type == AST_PROGRAM) {
        ASTNodeList *stmts = node->data.program.statements;
        if (stmts) {
            for (size_t i = 0; i < stmts->count; i++) {
                collect_functions(stmts->nodes[i], funcs, count, max);
            }
        }
    } else if (node->type == AST_BLOCK) {
        ASTNodeList *stmts = node->data.block.statements;
        if (stmts) {
            for (size_t i = 0; i < stmts->count; i++) {
                collect_functions(stmts->nodes[i], funcs, count, max);
            }
        }
    }
}

/* Emit forward declarations */
static void emit_forward_declarations(CodegenContext *ctx, ASTNode *ast) {
    ASTNode *funcs[100];
    int count = 0;
    
    collect_functions(ast, funcs, &count, 100);
    
    if (count > 0) {
        emit_line(ctx, "/* Forward declarations */");
        for (int i = 0; i < count; i++) {
            ASTNode *func = funcs[i];
            const char *ret_type = naturelang_type_to_c(func->data.func_decl.return_type);
            emit_indent(ctx);
            emit(ctx, "%s ", ret_type);
            emit_identifier(ctx, func->data.func_decl.name);
            emit(ctx, "(");
            
            ASTNodeList *params = func->data.func_decl.params;
            if (params && params->count > 0) {
                for (size_t j = 0; j < params->count; j++) {
                    if (j > 0) emit(ctx, ", ");
                    ASTNode *param = params->nodes[j];
                    const char *param_type = naturelang_type_to_c(param->data.param_decl.param_type);
                    emit(ctx, "%s ", param_type);
                    emit_identifier(ctx, param->data.param_decl.name);
                }
            } else {
                emit(ctx, "void");
            }
            
            emit(ctx, ");\n");
        }
        emit_newline(ctx);
    }
}

/* Generate main function wrapper */
static void emit_main_wrapper(CodegenContext *ctx, ASTNode *ast, int has_user_main) {
    if (has_user_main) {
        /* User defined their own main, just call it */
        emit_line(ctx, "int main(int argc, char *argv[]) {");
        emit_line(ctx, "    (void)argc; (void)argv;");
        emit_line(ctx, "    nl_main();");
        emit_line(ctx, "    return 0;");
        emit_line(ctx, "}");
    } else {
        /* Wrap top-level code in main */
        emit_line(ctx, "int main(int argc, char *argv[]) {");
        emit_line(ctx, "    (void)argc; (void)argv;");
        ctx->indent_level++;
        
        /* Generate top-level statements (skip function declarations) */
        if (ast->type == AST_PROGRAM) {
            ASTNodeList *stmts = ast->data.program.statements;
            if (stmts) {
                for (size_t i = 0; i < stmts->count; i++) {
                    ASTNode *stmt = stmts->nodes[i];
                    if (stmt->type != AST_FUNC_DECL) {
                        codegen_statement(ctx, stmt);
                    }
                }
            }
        }
        
        ctx->indent_level--;
        emit_line(ctx, "    return 0;");
        emit_line(ctx, "}");
    }
}

/* Check if there's a main function */
static int has_main_function(ASTNode *ast) {
    if (!ast) return 0;
    
    if (ast->type == AST_FUNC_DECL && 
        ast->data.func_decl.name && 
        strcmp(ast->data.func_decl.name, "main") == 0) {
        return 1;
    }
    
    if (ast->type == AST_PROGRAM) {
        ASTNodeList *stmts = ast->data.program.statements;
        if (stmts) {
            for (size_t i = 0; i < stmts->count; i++) {
                if (has_main_function(stmts->nodes[i])) {
                    return 1;
                }
            }
        }
    }
    
    return 0;
}

/* Main code generation entry point */
CodegenResult codegen_generate(CodegenContext *ctx, ASTNode *ast) {
    CodegenResult result = {0};
    
    if (!ctx || !ast) {
        result.success = 0;
        result.error_message = strdup("Invalid context or AST");
        return result;
    }
    
    /* Reset buffer */
    ctx->buffer_size = 0;
    ctx->buffer[0] = '\0';
    
    /* First pass: scan for features used */
    /* (This could be expanded to detect input/list usage) */
    ctx->needs_input_buffer = 1;  /* Always include for now */
    
    /* Emit headers */
    emit_headers(ctx);
    
    /* Emit global variables/buffers */
    emit_input_buffer(ctx);
    
    /* Emit forward declarations */
    emit_forward_declarations(ctx, ast);
    
    /* Check for user-defined main */
    int user_main = has_main_function(ast);
    
    /* Generate function declarations first */
    if (ast->type == AST_PROGRAM) {
        ASTNodeList *stmts = ast->data.program.statements;
        if (stmts) {
            for (size_t i = 0; i < stmts->count; i++) {
                ASTNode *stmt = stmts->nodes[i];
                if (stmt->type == AST_FUNC_DECL) {
                    /* Rename main to nl_main if user defined it */
                    char *func_name = stmt->data.func_decl.name;
                    if (func_name && strcmp(func_name, "main") == 0) {
                        char *old_name = func_name;
                        stmt->data.func_decl.name = strdup("nl_main");
                        codegen_function(ctx, stmt);
                        free(stmt->data.func_decl.name);
                        stmt->data.func_decl.name = old_name;
                    } else {
                        codegen_function(ctx, stmt);
                    }
                }
            }
        }
    }
    
    /* Generate main wrapper */
    emit_main_wrapper(ctx, ast, user_main);
    
    /* Prepare result */
    result.success = (ctx->error_count == 0);
    result.generated_code = strdup(ctx->buffer);
    result.code_length = ctx->buffer_size;
    result.error_count = ctx->error_count;
    if (ctx->error_count > 0) {
        result.error_message = strdup(ctx->error_message);
    }
    
    return result;
}

/* Generate code to file */
int codegen_to_file(CodegenContext *ctx, ASTNode *ast, const char *filename) {
    CodegenResult result = codegen_generate(ctx, ast);
    
    if (!result.success) {
        free(result.generated_code);
        free(result.error_message);
        return 0;
    }
    
    FILE *f = fopen(filename, "w");
    if (!f) {
        free(result.generated_code);
        return 0;
    }
    
    fputs(result.generated_code, f);
    fclose(f);
    
    free(result.generated_code);
    return 1;
}
